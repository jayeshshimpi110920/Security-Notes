## 1. What is LDAP?

### Basic Terminology
- **LDAP (Lightweight Directory Access Protocol)**: LDAP is a protocol used to access and manage directory services over a network. A directory service is a specialized database designed to store, retrieve, and manage information about users, groups, devices, and other resources in a hierarchical structure.
- **Directory**: A collection of data organized in a tree-like structure, often used to store user credentials (e.g., usernames, passwords, roles) or organizational data.
- **DN (Distinguished Name)**: A unique identifier for an entry in the LDAP directory, e.g., `cn=John Doe,ou=Users,dc=example,dc=com`.
  - **cn**: Common Name (e.g., a user's name).
  - **ou**: Organizational Unit (e.g., a department).
  - **dc**: Domain Component (e.g., a domain like example.com).
- **LDAP Query**: A request sent to the LDAP server to search, add, modify, or delete entries in the directory.
- **Filter**: A condition used in an LDAP query to narrow down results, e.g., `(uid=john)` searches for a user with the username "john."
- **Attributes**: Properties of an LDAP entry, such as `uid` (user ID), `mail`, or `givenName`.

### How LDAP Works
LDAP operates in a client-server model:
1. A client (e.g., a web application) sends an LDAP query to an LDAP server.
2. The server processes the query against the directory and returns the results (e.g., user details or authentication status).
3. Common use cases include:
   - User authentication (e.g., logging into an application).
   - Retrieving user roles or permissions.
   - Managing access to resources in an organization.

LDAP is widely used in enterprise environments (e.g., Active Directory, OpenLDAP) for centralized user management.

---

## 2. What is LDAP Injection?

### Definition
LDAP injection is a type of security vulnerability where an attacker manipulates an LDAP query by injecting malicious input into a web application's input fields (e.g., username or password fields). This occurs when user input is improperly sanitized before being included in an LDAP query, allowing attackers to alter the query's structure or logic.

For example, if a login form constructs an LDAP query like `(uid=$user_input)`, an attacker could input `admin)(&)`, modifying the query to bypass authentication or retrieve unauthorized data.

### Impact of LDAP Injection
LDAP injection can lead to severe security issues, including:
1. **Unauthorized Access**: Attackers can bypass authentication, gaining access to restricted accounts or systems.
2. **Data Exposure**: Sensitive information (e.g., user credentials, email addresses, or roles) stored in the LDAP directory may be exposed.
3. **Privilege Escalation**: Attackers may gain access to high-privilege accounts (e.g., admin accounts).
4. **Denial of Service (DoS)**: Malformed queries could overload the LDAP server, causing performance issues or crashes.
5. **Data Modification**: In some cases, attackers can modify or delete directory entries, disrupting system operations.

---

## 3. How to Find LDAP Injection in Source Code

### Key Indicators in Code
To identify potential LDAP injection vulnerabilities in source code, look for the following:
1. **Dynamic Query Construction**: Code that directly incorporates user input into LDAP queries without proper sanitization.
2. **Lack of Input Validation**: Absence of checks to ensure user input contains only expected characters (e.g., alphanumeric).
3. **Use of Unsafe LDAP APIs**: APIs that allow raw user input to be included in queries without escaping special characters like `(*)|&`.
4. **Hardcoded Filters with User Input**: Queries where user input is concatenated into LDAP filters, e.g., `(uid=$input)`.

### Common Patterns to Look For
- Use of string concatenation to build LDAP queries:
  ```java
  String query = "(uid=" + userInput + ")";
  ```
- Absence of escaping functions for LDAP special characters (e.g., `*`, `(`, `)`, `&`, `|`, `=`).
- Lack of parameterized queries or prepared statements for LDAP operations.
- Direct use of user input in LDAP search filters without validation.

### Steps to Review Code
1. **Search for LDAP-related Functions**: Look for APIs like `javax.naming.directory`, `ldap_search`, or `ldap_bind` in languages like Java, PHP, or Python.
2. **Trace User Input**: Follow the flow of user input (e.g., from HTTP requests) to see if it’s included in LDAP queries.
3. **Check for Sanitization**: Verify if the code escapes special characters or uses parameterized queries.
4. **Look for Error Handling**: Check if the code handles LDAP query errors, as improper error handling may expose query details to attackers.

---

## 4. Two Scenarios of LDAP Injection (Interview-Friendly)

### Scenario 1: Bypassing Authentication in a Login Form
**Context**: A web application uses LDAP to authenticate users by constructing a query like `(uid=$username)`. The application does not validate or escape the username input.

**Attack**:
- The attacker enters: `admin)(&)`
- Original query: `(uid=admin)(&)`
- This modifies the query to always return the `admin` user, bypassing password checks and granting unauthorized access.

**Interview Explanation**:
- Explain that LDAP injection occurs because the application concatenates unvalidated user input into the query.
- Highlight the impact: unauthorized access to sensitive accounts.
- Suggest mitigation: Use input validation and parameterized queries to prevent malicious input from altering the query.

### Scenario 2: Retrieving Unauthorized Data
**Context**: A search feature allows users to find colleagues by entering a partial name, constructing a query like `(cn=*$input*)`.

**Attack**:
- The attacker enters: `*`
- Original query: `(cn=**)`
- This returns all entries in the directory, exposing sensitive user data like emails or roles.

**Interview Explanation**:
- Describe how the wildcard (`*`) manipulates the query to retrieve unintended data.
- Emphasize the risk: exposure of sensitive directory information.
- Recommend mitigation: Sanitize input to disallow wildcards and limit query scope to specific attributes or organizational units.

---

## 5. Three Vulnerable Code Snippets (Different Languages and Scenarios)

### Snippet 1: Java (Authentication Vulnerability)
**Code**:
```java
import javax.naming.directory.*;

public class LDAPAuth {
    public boolean authenticate(String username, String password) {
        String ldapUrl = "ldap://example.com:389";
        String baseDn = "dc=example,dc=com";
        String filter = "(uid=" + username + ")";
        
        DirContext ctx = new InitialDirContext();
        SearchControls sc = new SearchControls();
        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);
        
        NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, sc);
        return results.hasMore(); // Authenticate if user exists
    }
}
```

**Why It’s Vulnerable**:
- The `username` input is directly concatenated into the LDAP filter without sanitization.
- An attacker can input `admin)(&)` to modify the query to `(uid=admin)(&)`, bypassing authentication.

**Mitigation**:
- **Sanitize Input**: Escape special characters (e.g., `*`, `(`, `)`, `&`) using a library like `org.apache.directory.api.ldap.model.filter.FilterEncoder`.
- **Use Parameterized Queries**: Avoid string concatenation by using placeholders.
- **Validate Input**: Ensure `username` contains only alphanumeric characters.

**Mitigated Code**:
```java
import org.apache.directory.api.ldap.model.filter.FilterEncoder;

public class LDAPAuth {
    public boolean authenticate(String username, String password) {
        // Validate input
        if (!username.matches("[a-zA-Z0-9]+")) {
            throw new IllegalArgumentException("Invalid username");
        }
        
        String ldapUrl = "ldap://example.com:389";
        String baseDn = "dc=example,dc=com";
        String filter = "(uid={0})";
        String escapedFilter = FilterEncoder.format(filter, username);
        
        DirContext ctx = new InitialDirContext();
        SearchControls sc = new SearchControls();
        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);
        
        NamingEnumeration<SearchResult> results = ctx.search(baseDn, escapedFilter, sc);
        return results.hasMore();
    }
}
```

---

### Snippet 2: PHP (Search Functionality Vulnerability)
**Code**:
```php
<?php
$ldapconn = ldap_connect("ldap://example.com");
$base_dn = "dc=example,dc=com";
$search_input = $_GET['search']; // User input from search form
$filter = "(cn=*$search_input*)";

$sr = ldap_search($ldapconn, $base_dn, $filter);
$entries = ldap_get_entries($ldapconn, $sr);

foreach ($entries as $entry) {
    echo "Name: " . $entry['cn'][0] . "<br>";
}
?>
```

**Why It’s Vulnerable**:
- The `search_input` is directly included in the LDAP filter, allowing attackers to input wildcards like `*` to retrieve all directory entries.
- No validation or escaping of special characters.

**Mitigation**:
- **Escape Special Characters**: Use `ldap_escape()` to sanitize input.
- **Restrict Query Scope**: Limit the attributes returned (e.g., only `cn`).
- **Input Validation**: Allow only expected characters (e.g., letters and spaces).

**Mitigated Code**:
```php
<?php
$ldapconn = ldap_connect("ldap://example.com");
$base_dn = "dc=example,dc=com";
$search_input = $_GET['search'];

// Validate input
if (!preg_match("/^[a-zA-Z ]+$/", $search_input)) {
    die("Invalid search input");
}

// Escape special characters
$escaped_input = ldap_escape($search_input, null, LDAP_ESCAPE_FILTER);
$filter = "(cn=*$escaped_input*)";

$sr = ldap_search($ldapconn, $base_dn, $filter, ['cn']); // Limit attributes
$entries = ldap_get_entries($ldapconn, $sr);

foreach ($entries as $entry) {
    echo "Name: " . htmlspecialchars($entry['cn'][0]) . "<br>";
}
?>
```

---

### Snippet 3: Python (User Lookup Vulnerability)
**Code**:
```python
import ldap

def lookup_user(user_input):
    con = ldap.initialize('ldap://example.com')
    base_dn = "dc=example,dc=com"
    filter = f"(uid={user_input})"
    
    result = con.search_s(base_dn, ldap.SCOPE_SUBTREE, filter)
    for dn, entry in result:
        print(f"User: {entry['uid'][0].decode()}")
```

**Why It’s Vulnerable**:
- The `user_input` is directly embedded in the filter string, allowing attackers to inject malicious input like `*)(uid=*))(|(uid=*` to retrieve all users.
- No sanitization or validation of input.

**Mitigation**:
- **Sanitize Input**: Use a library to escape LDAP special characters.
- **Validate Input**: Restrict input to alphanumeric characters.
- **Use Parameterized Filters**: Avoid string concatenation.

**Mitigated Code**:
```python
import ldap
import re

def lookup_user(user_input):
    # Validate input
    if not re.match("^[a-zA-Z0-9]+$", user_input):
        raise ValueError("Invalid user input")
    
    con = ldap.initialize('ldap://example.com')
    base_dn = "dc=example,dc=com"
    
    # Escape special characters
    safe_input = ldap.filter.escape_filter_chars(user_input)
    filter = f"(uid={safe_input})"
    
    result = con.search_s(base_dn, ldap.SCOPE_SUBTREE, filter, ['uid'])
    for dn, entry in result:
        print(f"User: {entry['uid'][0].decode()}")
```

---

## 6. How to Find LDAP Injection Using DAST

### Steps for Manual Testing
Dynamic Application Security Testing (DAST) involves testing the application in a running state to identify vulnerabilities like LDAP injection. Here’s how to test manually:

1. **Identify Input Points**:
   - Look for input fields that interact with an LDAP directory, such as login forms, search fields, or profile lookup features.
   - Common fields include username, password, or search inputs.

2. **Craft Malicious Inputs**:
   - Inject LDAP special characters to manipulate the query:
     - `*`: Wildcard to match any value.
     - `)`: Closes a condition prematurely.
     - `&`, `|`: Logical operators to combine conditions.
     - `)(&)`, `*)(uid=*)`: Common payloads to bypass authentication or retrieve all entries.
   - Example inputs:
     - `admin)(&)`
     - `*`
     - `*)(uid=*)`

3. **Submit Payloads**:
   - Use a browser or tools like Burp Suite to intercept and modify HTTP requests.
   - Submit payloads in input fields and observe the application’s response.

4. **Analyze Responses**:
   - Look for unusual behavior, such as:
     - Successful login without a valid password (indicating authentication bypass).
     - Retrieval of unexpected data (e.g., multiple user records from a search).
     - Error messages exposing LDAP query details (e.g., “Invalid filter syntax”).
   - Compare responses with valid inputs to identify anomalies.

5. **Use Tools for Automation**:
   - Tools like Burp Suite, OWASP ZAP, or custom scripts can automate payload injection.
   - Configure payloads to include LDAP-specific characters and monitor responses.

### Identifying LDAP Injection in Results
To confirm LDAP injection, look for:
- **Authentication Bypass**: Logging in with an invalid password using payloads like `admin)(&)`.
- **Data Exposure**: Retrieving multiple records or sensitive data with inputs like `*`.
- **Error Messages**: LDAP-specific errors (e.g., “Invalid DN syntax” or “Filter error”) indicate query manipulation.
- **Unexpected Behavior**: The application returns data or behaves differently than expected for malicious inputs.

### Example Test Case
- **Test**: In a login form, enter `admin)(&)` as the username and any password.
- **Result**: If the application logs you in as “admin,” it’s vulnerable to LDAP injection.
- **Confirmation**: Test with a valid username and password to ensure the behavior is due to the payload.

---

## 7. Mitigation Strategies for LDAP Injection

To prevent LDAP injection, implement the following best practices:
1. **Input Validation**:
   - Restrict user input to expected characters (e.g., alphanumeric only) using regular expressions.
   - Example: `^[a-zA-Z0-9]+$`

2. **Escape Special Characters**:
   - Use language-specific libraries to escape LDAP special characters:
     - Java: `org.apache.directory.api.ldap.model.filter.FilterEncoder`
     - PHP: `ldap_escape()`
     - Python: `ldap.filter.escape_filter_chars`
   - Escape characters like `*`, `(`, `)`, `&`, `|`, `=`, and `\`.

3. **Use Parameterized Queries**:
   - Avoid string concatenation for LDAP filters.
   - Use APIs that support parameterized queries or prepared statements.

4. **Limit Query Scope**:
   - Restrict LDAP queries to specific attributes (e.g., `uid`, `cn`) or organizational units.
   - Avoid queries that return all entries (e.g., `(objectClass=*)`).

5. **Least Privilege Principle**:
   - Configure LDAP accounts used by the application with minimal permissions (e.g., read-only for authentication).
   - Limit access to sensitive directory branches.

6. **Error Handling**:
   - Avoid exposing LDAP error messages to users, as they may reveal query structure.
   - Log errors internally for debugging.

7. **Regular Security Testing**:
   - Perform code reviews and DAST to identify LDAP injection vulnerabilities.
   - Use tools like OWASP ZAP or Burp Suite to test for injection.

---
