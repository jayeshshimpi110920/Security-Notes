
## üîê What is XSS?

**Cross-Site Scripting (XSS)** is a web vulnerability that allows attackers to inject malicious scripts into web pages viewed by others. These scripts can **steal cookies**, **session tokens**, or perform **malicious actions on behalf of the user**.

---

## üß© Types of XSS:

1. **Stored XSS** (Persistent) - Malicious script is reflected off a web server in an immediate response.
2. **Reflected XSS** - Malicious script is stored on the server (e.g., in a database) and executed when retrieved.
3. **DOM-based XSS**  - The vulnerability exists in client-side JavaScript rather than server-side code.

---

## 1. üîÅ Stored XSS

Stored XSS occurs when the malicious script is **stored on the server** (e.g., in a database), and then rendered in a web page viewed by other users.

---

### ‚úÖ Example 1: Stored XSS in Comment Section

```php
<!-- Vulnerable PHP Code -->
<?php
  $comment = $_POST['comment'];
  // Stored in DB, then retrieved
  echo "<div>$comment</div>";
?>
```

#### Why it's vulnerable:

* **No input sanitization or output encoding**.
* Attacker submits: `<script>alert('XSS')</script>`, which gets stored and displayed as executable JavaScript.

---

### ‚úÖ Example 2: Stored XSS in User Profile

```javascript
// Node.js / Express example
app.post('/updateProfile', (req, res) => {
  let bio = req.body.bio;
  // Save 'bio' to database
  res.send(`<p>Your bio: ${bio}</p>`);
});
```

#### Why it's vulnerable:

* Data directly rendered without sanitizing.
* Attacker sets bio to `<img src=x onerror=alert(1)>`.

---

## 2. üîÑ Reflected XSS

Reflected XSS occurs when the malicious input is **immediately returned by the server** in the response, usually via URL parameters.

---

### ‚úÖ Example 1: Reflected XSS via Search

```php
<!-- Vulnerable PHP Code -->
<?php
  $q = $_GET['q'];
  echo "You searched for: $q";
?>
```

#### Why it's vulnerable:

* No output encoding.
* URL: `?q=<script>alert('XSS')</script>` executes JavaScript.

---

### ‚úÖ Example 2: Reflected XSS in Error Page

```python
# Vulnerable Flask app
@app.route('/error')
def error():
    msg = request.args.get('msg')
    return f"<h1>Error: {msg}</h1>"
```

#### Why it's vulnerable:

* Attacker sends: `/error?msg=<script>alert(1)</script>`.
* Script gets executed when user opens the URL.

---

## 3. üß† DOM-Based XSS 

dom - docuemnt object model <br>
DOM-based XSS occurs **entirely in the browser**, due to insecure client-side JavaScript handling of data.
How it works: The attack manipulates the DOM (e.g., via document.location, innerHTML, eval())

---

### ‚úÖ Example 1: DOM XSS in URL Hash

```html
<!-- Vulnerable JavaScript -->
<div id="content"></div>
<script>
  document.getElementById('content').innerHTML = location.hash.substring(1);
</script>
```

#### Why it's vulnerable:

* URL: `page.html#<img src=x onerror=alert(1)>`
* Browser injects untrusted content into the DOM.

---

### ‚úÖ Example 2: DOM XSS with `document.write`

```html
<script>
  var name = new URLSearchParams(location.search).get("name");
  document.write("Welcome " + name);
</script>
```

#### Why it's vulnerable:

* URL: `?name=<script>alert(1)</script>`
* `document.write` executes embedded script.

---

## üõ°Ô∏è How to Prevent XSS

1. **Escape Output** ‚Äì Use context-aware escaping.
2. **Sanitize Input** ‚Äì Filter out dangerous characters.
3. **Use Security Libraries** ‚Äì Like DOMPurify for DOM.
4. **HTTP-only Cookies** ‚Äì So scripts can't access them.
5. **Content Security Policy (CSP)** ‚Äì Restricts script execution.

---

### How to mitigate those vulnerabilities - 
The original PHP code is vulnerable to Cross-Site Scripting (XSS) attacks because it directly outputs user input (`$_POST['comment']`) without any sanitization or escaping. Here's the remediated code with proper security measures:

```php
<?php
  $comment = $_POST['comment'];
  // Stored in DB, then retrieved
  
  // Remediation: Properly escape output before displaying
  echo "<div>" . htmlspecialchars($comment, ENT_QUOTES | ENT_HTML5, 'UTF-8') . "</div>";
?>
```

Key security improvements:

1. **Output Escaping**: Used `htmlspecialchars()` to convert special characters to HTML entities, preventing XSS attacks.
   - `ENT_QUOTES` flag escapes both single and double quotes
   - `ENT_HTML5` specifies HTML5 handling of characters
   - 'UTF-8' specifies character encoding

Additional recommendations for a complete solution:

1. **Input Validation** (server-side):
   ```php
   $comment = trim($_POST['comment']);
   if (empty($comment)) {
       // Handle empty comment
   }
   // Validate length, format, etc. as needed
   ```

2. **Database Security** (if storing):
   - Use prepared statements with PDO or MySQLi to prevent SQL injection
   - Example with PDO:
     ```php
     $stmt = $pdo->prepare("INSERT INTO comments (comment) VALUES (:comment)");
     $stmt->bindParam(':comment', $comment);
     $stmt->execute();
     ```

3. **Content Security Policy** (CSP):
   - Implement CSP headers as an additional layer of protection

4. **For rich content** (if you need to allow some HTML):
   - Use a dedicated HTML sanitizer library like HTML Purifier

The key principle is: always escape output according to the context where it will be displayed (HTML, JavaScript, CSS, etc.), and validate input according to what you expect to receive.

---
### DAST how to find it manually --

Identifying **XSS (Cross-Site Scripting)** vulnerabilities in **Dynamic Application Security Testing (DAST)** requires testing for all three types of XSS:  

1. **Reflected XSS** ‚Äì Malicious script is reflected off a web server in an immediate response.  
2. **Stored XSS** ‚Äì Malicious script is stored on the server (e.g., in a database) and executed when retrieved.  
3. **DOM-based XSS** ‚Äì The vulnerability exists in client-side JavaScript rather than server-side code.  

### **DAST Approach to Detect All 3 XSS Types**  

#### **1. Reflected XSS Detection (Non-Persistent)**
- **How it works**: The attack payload appears in the URL or POST data and is immediately reflected in the response.
- **DAST Testing Method**:
  - **Fuzz all input parameters** (GET, POST, headers, cookies) with XSS payloads.
  - Check if the payload executes in the response without proper escaping.
  - **Example Payloads**:
    ```html
    <script>alert(1)</script>
    "><script>alert(1)</script>
    'onfocus=alert(1) autofocus='
    ```
  - **Tools**: OWASP ZAP, Burp Suite (with Active Scan), Acunetix.

#### **2. Stored XSS Detection (Persistent)**
- **How it works**: The payload is stored in a database (e.g., comments, user profiles) and executed when other users view the page.
- **DAST Testing Method**:
  - Submit XSS payloads in **user-controllable storage inputs** (forms, file uploads, profile fields).
  - Check if the payload is rendered unescaped when the page is reloaded or viewed by another user.
  - **Example Payloads**:
    ```html
    <img src=x onerror=alert(1)>
    <svg/onload=alert(1)>
    ```
  - **Tools**: Burp Suite (Repeater/Scanner), Nessus, Detectify.

#### **3. DOM-based XSS Detection (Client-Side Only)**
- **How it works**: The attack manipulates the DOM (e.g., via `document.location`, `innerHTML`, `eval()`).
- **DAST Testing Method**:
  - **Test URL fragments (`#`) and JS-based inputs** (e.g., `?param=<script>alert(1)</script>`).
  - Monitor browser DevTools (**Console, Sources, Debugger**) for JS execution.
  - **Example Payloads**:
    ```javascript
    #<img src=x onerror=alert(1)>
    javascript:alert(1)
    ```
  - **Tools**:
    - **Burp Suite DOM Invader** (for manual testing).
    - **OWASP ZAP** (with AJAX Spider).
    - **Browser DevTools** (manual inspection of `eval()`, `innerHTML`).


### **Key Takeaways**
- **For Reflected XSS**: Test all input parameters (GET/POST) with script payloads.
- **For Stored XSS**: Submit malicious scripts in persistent storage fields (comments, profiles).
- **For DOM XSS**: Check URL fragments (`#`), `eval()`, `innerHTML`, and client-side sinks.
- **Use a mix of automated scanning (DAST) and manual testing** (Burp Suite, DevTools).

Would you like a step-by-step guide for testing XSS with a specific tool like **Burp Suite** or **OWASP ZAP**?
