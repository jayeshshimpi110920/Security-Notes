SAST/Manual source code review : https://youtu.be/HKDe1z7_AII?si=F6XbKXzKIEd8L9Kd <br>
XXE : https://youtu.be/gjm6VHZa_8s?si=Yxe5esaCckFr6p0_

---

## 1. What is XXE?

### Basic Terminology
- **XML (Extensible Markup Language)**: A markup language used to structure, store, and transport data. XML is widely used in web applications, APIs, and configuration files to represent data hierarchically (e.g., `<user><name>John</name></user>`).
- **XML Parser**: A software component that processes XML data, interpreting its structure and content. Common XML parsers include `libxml2` (PHP), `SAX` (Java), and `xml.etree.ElementTree` (Python).
- **Entity**: A mechanism in XML to define reusable data, declared within a Document Type Definition (DTD). Entities can represent text, files, or external resources.
  - **Internal Entity**: Defined within the XML, e.g., `<!ENTITY name "John">`.
  - **External Entity**: References external resources, e.g., `<!ENTITY data SYSTEM "file:///etc/passwd">`.
- **DTD (Document Type Definition)**: A set of rules that defines the structure and data types of an XML document. It often includes entity declarations.
- **SYSTEM and PUBLIC Keywords**: Used in DTDs to reference external resources (e.g., files or URLs) in external entities.
- **XXE (XML External Entity)**: A feature of XML that allows entities to reference external resources, such as files or network locations, using the `SYSTEM` keyword.

### How XML and XXE Work
XML documents can include a DTD to define entities. An XML parser processes these entities, resolving references to internal or external data. For example:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE note [
  <!ENTITY data SYSTEM "file:///etc/passwd">
]>
<note>
  <content>&data;</content>
</note>
```
- The parser replaces `&data;` with the contents of `/etc/passwd` when processing the XML.
- XXE vulnerabilities arise when an application processes untrusted XML input that includes malicious external entities, allowing attackers to access sensitive resources.

---

## 2. What is XXE Injection?

### Definition
XXE injection is a security vulnerability that occurs when an application processes XML input containing malicious external entity declarations without proper validation or parser configuration. Attackers exploit XXE to include external entities that access sensitive files, make network requests, or execute other malicious actions.

For example, an attacker might submit XML like:
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>
```
This could trick the server into returning the contents of `/etc/passwd`.

### Impact of XXE Injection
XXE injection can lead to severe security issues, including:
1. **Sensitive Data Exposure**: Attackers can read sensitive files (e.g., `/etc/passwd`, configuration files) from the server.
2. **Server-Side Request Forgery (SSRF)**: Attackers can make the server send requests to internal or external systems, potentially accessing internal APIs or services.
3. **Denial of Service (DoS)**: Malicious entities (e.g., referencing `/dev/random` or recursive entities like Billion Laughs attacks) can consume server resources, causing crashes or slowdowns.
4. **Remote Code Execution (RCE)**: In rare cases, with certain parsers or misconfigured systems, XXE can lead to code execution (e.g., via PHP’s `expect://` wrapper).
5. **Data Integrity Issues**: Attackers may manipulate application logic by injecting unexpected data through entities.

---

## 3. How to Find XXE Injection in Source Code

### Key Indicators in Code
To identify potential XXE vulnerabilities in source code, look for the following:
1. **XML Parsing with User Input**: Code that processes XML input from untrusted sources (e.g., user uploads, API requests) without disabling external entity resolution.
2. **Use of Vulnerable Parsers**: XML parsers that enable external entity processing by default (e.g., Java’s `DocumentBuilder`, PHP’s `simplexml_load_string`, Python’s `xml.etree.ElementTree`).
3. **Lack of DTD Disabling**: Failure to disable DTD processing or external entity resolution in the parser configuration.
4. **No Input Validation**: Absence of checks to ensure XML input is safe or conforms to an expected structure.

### Common Patterns to Look For
- Use of XML parsing APIs without explicit configuration to disable external entities:
  ```java
  DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
  Document doc = db.parse(new InputSource(new StringReader(xmlInput)));
  ```
- Accepting raw XML input from HTTP requests or file uploads without sanitization.
- Absence of parser settings like `setFeature` to disable DTD or external entity processing.
- Error handling that exposes XML parsing errors, potentially revealing parser details.

### Steps to Review Code
1. **Identify XML Parsing Code**: Search for XML parsing libraries (e.g., `DocumentBuilder` in Java, `simplexml_load_string` in PHP, `xml.etree.ElementTree` in Python).
2. **Check Parser Configuration**: Verify if the parser explicitly disables DTDs or external entities.
3. **Trace User Input**: Follow the flow of user-controlled input (e.g., from HTTP POST requests) to see if it’s included in XML parsing.
4. **Look for Validation**: Check if the code validates XML structure or restricts DTD usage.

---

## 4. Two Scenarios of XXE Injection (Interview-Friendly)

### Scenario 1: File Disclosure via XXE
**Context**: A web application allows users to upload XML files to process user profiles. The application parses the XML using a default parser configuration.

**Attack**:
- The attacker uploads:
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
  <profile>
    <name>&xxe;</name>
  </profile>
  ```
- The server processes the XML and includes the contents of `/etc/passwd` in the response.

**Interview Explanation**:
- Explain that the vulnerability occurs because the XML parser processes external entities without restrictions.
- Highlight the impact: exposure of sensitive server files.
- Suggest mitigation: Disable external entity processing in the parser and validate XML input.

### Scenario 2: SSRF via XXE
**Context**: An API accepts XML input to process orders and uses a default XML parser. The server is behind a firewall, but internal services are accessible.

**Attack**:
- The attacker submits:
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal-service:8080/admin">]>
  <order>
    <details>&xxe;</details>
  </order>
  ```
- The server makes a request to `http://internal-service:8080/admin`, potentially exposing internal data in the response.

**Interview Explanation**:
- Describe how the external entity forces the server to make unauthorized network requests.
- Emphasize the risk: accessing internal systems or APIs (SSRF).
- Recommend mitigation: Disable external entity resolution and restrict network access.

---

## 5. Three Vulnerable Code Snippets (Different Languages and Scenarios)

### Snippet 1: Java (File Disclosure Vulnerability)
**Code**:
```java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.xml.sax.InputSource;
import java.io.StringReader;

public class XMLProcessor {
    public String parseXML(String xmlInput) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        InputSource is = new InputSource(new StringReader(xmlInput));
        Document doc = builder.parse(is);
        
        return doc.getDocumentElement().getTextContent();
    }
}
```

**Why It’s Vulnerable**:
- The `DocumentBuilderFactory` is used with its default configuration, which allows DTD processing and external entity resolution.
- An attacker can submit XML with an external entity (e.g., `<!ENTITY xxe SYSTEM "file:///etc/passwd">`) to read sensitive files.

**Mitigation**:
- **Disable DTD Processing**: Set `setFeature` to disable DTDs and external entities.
- **Validate Input**: Ensure XML input conforms to an expected structure.
- **Use Secure Parsers**: Consider safer alternatives like `SAXParser` with proper configuration.

**Mitigated Code**:
```java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.xml.sax.InputSource;
import java.io.StringReader;

public class XMLProcessor {
    public String parseXML(String xmlInput) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        // Disable DTD and external entities
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setXIncludeAware(false);
        factory.setExpandEntityReferences(false);
        
        DocumentBuilder builder = factory.newDocumentBuilder();
        InputSource is = new InputSource(new StringReader(xmlInput));
        Document doc = builder.parse(is);
        
        return doc.getDocumentElement().getTextContent();
    }
}
```

---

### Snippet 2: PHP (SSRF Vulnerability)
**Code**:
```php
<?php
$xmlInput = $_POST['xml']; // User-submitted XML
$xml = simplexml_load_string($xmlInput, 'SimpleXMLElement', LIBXML_NOENT);

echo $xml->data;
?>
```

**Why It’s Vulnerable**:
- The `simplexml_load_string` function is used with `LIBXML_NOENT`, which enables entity substitution, allowing external entities to be processed.
- An attacker can submit XML with an external entity (e.g., `<!ENTITY xxe SYSTEM "http://malicious.com">`) to trigger SSRF.

**Mitigation**:
- **Disable Entity Processing**: Avoid `LIBXML_NOENT` and use `LIBXML_DTDLOAD` only if necessary.
- **Validate XML**: Use a schema or whitelist to restrict XML structure.
- **Sanitize Input**: Remove or reject XML containing `<!DOCTYPE>` declarations.

**Mitigated Code**:
```php
<?php
$xmlInput = $_POST['xml'];

// Basic validation to reject DOCTYPE
if (stripos($xmlInput, '<!DOCTYPE') !== false) {
    die("Invalid XML: DOCTYPE not allowed");
}

$xml = simplexml_load_string($xmlInput, 'SimpleXMLElement', 0); // Disable entity processing
if ($xml === false) {
    die("Invalid XML");
}

echo htmlspecialchars($xml->data);
?>
```

---

### Snippet 3: Python (DoS Vulnerability)
**Code**:
```python
import xml.etree.ElementTree as ET

def parse_xml(xml_input):
    parser = ET.XMLParser()
    root = ET.fromstring(xml_input, parser=parser)
    return root.find('data').text
```

**Why It’s Vulnerable**:
- The `xml.etree.ElementTree` parser processes DTDs and external entities by default.
- An attacker can submit a Billion Laughs attack (recursive entity expansion) or reference a resource like `/dev/random` to cause a DoS:
  ```xml
  <!DOCTYPE lolz [<!ENTITY lol "lol"><!ENTITY lol1 "&lol;&lol;"> ... ]>
  <data>&lol9;</data>
  ```

**Mitigation**:
- **Disable DTD Processing**: Use a custom parser that rejects DTDs.
- **Validate Input**: Check for `<!DOCTYPE>` declarations.
- **Limit Resource Usage**: Restrict memory and CPU usage during XML parsing.

**Mitigated Code**:
```python
import xml.etree.ElementTree as ET
import defusedxml.ElementTree as DefusedET

def parse_xml(xml_input):
    # Use defusedxml for secure parsing
    try:
        root = DefusedET.fromstring(xml_input)
        return root.find('data').text
    except DefusedET.EntitiesForbidden:
        raise ValueError("XML entities are not allowed")
    except:
        raise ValueError("Invalid XML")
```

---

## 6. How to Find XXE Injection Using DAST

### Steps for Manual Testing
Dynamic Application Security Testing (DAST) involves testing a running application to identify vulnerabilities like XXE. Here’s how to test manually:

1. **Identify XML Input Points**:
   - Look for endpoints that accept XML input, such as file uploads, API POST requests, or form submissions with XML content types (e.g., `application/xml`).
   - Common locations include user profile uploads, API payloads, or SOAP-based web services.

2. **Craft Malicious XML Payloads**:
   - Test for file disclosure:
     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
     <root><data>&xxe;</data></root>
     ```
   - Test for SSRF:
     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://malicious.com">]>
     <root><data>&xxe;</data></root>
     ```
   - Test for DoS (Billion Laughs):
     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <!DOCTYPE lolz [
       <!ENTITY lol "lol">
       <!ENTITY lol1 "&lol;&lol;">
       <!ENTITY lol2 "&lol1;&lol1;">
       <!ENTITY lol3 "&lol2;&lol2;">
     ]>
     <root><data>&lol3;</data></root>
     ```

3. **Submit Payloads**:
   - Use tools like Burp Suite or Postman to send XML payloads via HTTP requests.
   - Modify the `Content-Type` header to `application/xml` if needed.
   - Test file uploads, POST requests, or query parameters that may be processed as XML.

4. **Analyze Responses**:
   - Check for sensitive data (e.g., contents of `/etc/passwd`) in the response.
   - Look for unexpected network activity (e.g., SSRF responses from external URLs).
   - Monitor for errors (e.g., “XML parsing error” or timeouts) that indicate DoS or parser issues.
   - Compare responses with valid XML to identify anomalies.

5. **Use Automated Tools**:
   - Tools like Burp Suite, OWASP ZAP, or Nikto can automate XXE payload injection.
   - Configure payloads to include common XXE vectors and monitor for successful exploitation.

### Identifying XXE Injection in Results
To confirm XXE injection, look for:
- **File Content in Response**: Sensitive file contents (e.g., `/etc/passwd`) indicate successful file disclosure.
- **Network Responses**: Data from external or internal URLs suggests SSRF.
- **Application Slowdown or Crash**: A DoS payload (e.g., Billion Laughs) may cause timeouts or high resource usage.
- **Error Messages**: Parser errors revealing DTD processing or entity expansion confirm XXE vulnerability.
- **Unexpected Behavior**: The application processes malicious XML differently than valid XML.

### Example Test Case
- **Test**: Submit the file disclosure payload via a POST request to an XML-processing endpoint.
- **Result**: If the response contains `/etc/passwd` contents, the application is vulnerable to XXE.
- **Confirmation**: Test with a harmless XML payload to ensure the behavior is due to the malicious entity.

---

## 7. Mitigation Strategies for XXE Injection

To prevent XXE injection, implement the following best practices:
1. **Disable DTD and External Entities**:
   - Configure XML parsers to reject DTDs and external entities:
     - Java: `factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true)`
     - PHP: Avoid `LIBXML_NOENT` and use `LIBXML_DTDLOAD` only if necessary.
     - Python: Use `defusedxml` instead of `xml.etree.ElementTree`.
   - Example libraries: `defusedxml` (Python), `libxml2` with secure settings (PHP).

2. **Use Secure Parsers**:
   - Choose parsers that are hardened against XXE, such as `defusedxml` or `SAX` with proper configuration.
   - Avoid default parser settings that enable entity resolution.

3. **Validate XML Input**:
   - Use XML schemas (XSD) or whitelists to ensure input conforms to expected structures.
   - Reject XML containing `<!DOCTYPE>` declarations.

4. **Sanitize Input**:
   - Remove or escape DTD-related content before parsing.
   - Validate content types to ensure only expected XML is processed.

5. **Limit Network Access**:
   - Configure firewalls to block outgoing requests from the server to prevent SSRF.
   - Restrict access to sensitive files (e.g., `/etc/passwd`) via file system permissions.

6. **Error Handling**:
   - Suppress detailed XML parsing errors to prevent leakage of parser or server details.
   - Log errors internally for debugging.

7. **Regular Security Testing**:
   - Perform code reviews and DAST to identify XXE vulnerabilities.
   - Use tools like OWASP ZAP or Burp Suite to test XML endpoints.

---
