### CSRF Vulnerabilities

**Cross-Site Request Forgery (CSRF)** is a type of security vulnerability that allows an attacker to trick an authenticated user into performing unintended actions on a web application where they are logged in. This occurs when a malicious website, email, or other medium causes a user's browser to send a forged request to the target application, leveraging the user's active session to execute actions without their knowledge or consent.

CSRF exploits the trust that a web application has in the user's browser, as the application assumes requests originating from the browser are legitimate. If the application does not validate the origin or authenticity of the request, attackers can manipulate the user into performing actions like changing account details, transferring funds, or deleting data.

---

### Two UI Scenarios Demonstrating CSRF

1. **Scenario 1: Changing User Profile Information**
   - **Description**: A user is logged into a banking application at `https://bank.com`. The application has a form to update the user's email address via a POST request to `https://bank.com/update_email`. An attacker creates a malicious website with a hidden form that submits a POST request to the same endpoint, changing the email to one controlled by the attacker.
   - **User Interaction**: The user visits the malicious website (e.g., `http://evil.com`) while logged into the banking application. The hidden form automatically submits, updating the email without the user’s knowledge.
   - **Outcome**: The attacker gains control of the account by resetting the password to the new email address.

2. **Scenario 2: Unauthorized Fund Transfer**
   - **Description**: A shopping website allows users to transfer funds to another account via a GET request like `https://shop.com/transfer?amount=1000&to=attacker_account`. An attacker embeds this URL in an `<img>` tag on a malicious site.
   - **User Interaction**: The user, logged into the shopping site, visits the malicious site. The browser automatically loads the `<img>` tag, triggering the GET request and transferring funds to the attacker’s account.
   - **Outcome**: Funds are transferred without the user’s consent, exploiting the active session.

---

### Impact of CSRF Vulnerabilities

- **Unauthorized Actions**: Attackers can perform actions on behalf of the user, such as changing account settings, making purchases, or deleting data.
- **Financial Loss**: In applications like banking or e-commerce, CSRF can lead to unauthorized fund transfers or purchases.
- **Data Integrity Issues**: Attackers can modify or delete user data, compromising the application’s integrity.
- **Account Compromise**: CSRF can facilitate account takeovers by changing email addresses or passwords.
- **Reputational Damage**: Breaches caused by CSRF can erode user trust and lead to regulatory penalties (e.g., GDPR, CCPA).

---

### Finding CSRF Vulnerabilities in Source Code

To identify CSRF vulnerabilities in source code, look for the following:

1. **Lack of CSRF Tokens**:
   - Check if forms or state-changing requests (e.g., POST, PUT, DELETE) include a unique, unpredictable CSRF token.
   - Look for missing or improperly implemented token validation on the server side.

2. **State-Changing GET Requests**:
   - Identify GET requests that modify data (e.g., `GET /delete_user?id=123`), as these are inherently vulnerable to CSRF since browsers can automatically issue them via tags like `<img>` or `<script>`.

3. **Missing Origin/Referer Header Checks**:
   - Verify if the server validates the `Origin` or `Referer` HTTP headers to ensure requests originate from trusted domains.

4. **Session-Based Authentication Without Protection**:
   - Look for endpoints that rely solely on session cookies for authentication without additional CSRF protection.

5. **Insecure Framework Configurations**:
   - Check if the framework’s built-in CSRF protection (e.g., Django’s `CsrfViewMiddleware`, Laravel’s `VerifyCsrfToken`) is disabled or misconfigured.

**Tips for Source Code Review**:
- Search for keywords like `POST`, `PUT`, `DELETE`, `form`, or `action` to locate state-changing endpoints.
- Check for the presence of CSRF token generation and validation functions (e.g., `csrf_token()` in Django, `Csrf-Token` in headers).
- Use static analysis tools (e.g., SonarQube, Checkmarx) to flag missing CSRF protections.
- Review form-handling code to ensure tokens are included and validated.
- Look for AJAX requests that modify data and verify if they include CSRF tokens in headers.

---

### CSRF Vulnerabilities in Three Different Languages with Scenarios

Below are three code snippets in different languages, each demonstrating a CSRF vulnerability in a unique scenario, with explanations of why they are vulnerable and how to mitigate them.

#### 1. **Python (Django) - User Profile Update**
**Scenario**: A Django application allows users to update their email address via a POST request. The form lacks CSRF protection, making it vulnerable to CSRF attacks.

```python
# views.py
from django.http import HttpResponse
from django.views import View

class UpdateEmailView(View):
    def post(self, request):
        # Vulnerable: No CSRF token validation
        email = request.POST.get('email')
        # Update email in database (simulated)
        return HttpResponse(f"Email updated to {email}")

# templates/update_email.html
html = """
<form method="POST" action="/update_email">
    <input type="email" name="email" placeholder="New email">
    <button type="submit">Update Email</button>
</form>
"""
```

**Why It’s Vulnerable**:
- The form in `update_email.html` does not include a CSRF token (`{% csrf_token %}`).
- The view does not enforce CSRF validation (e.g., via Django’s `@csrf_protect` or middleware).
- An attacker can create a malicious form on their site (e.g., `<form action="https://target.com/update_email" method="POST">`) to trick the user’s browser into submitting the request.

**How to Mitigate**:
- Enable Django’s CSRF middleware (`django.middleware.csrf.CsrfViewMiddleware`) in `settings.py`.
- Add `{% csrf_token %}` to the form:
  ```html
  <form method="POST" action="/update_email">
      {% csrf_token %}
      <input type="email" name="email" placeholder="New email">
      <button type="submit">Update Email</button>
  </form>
  ```
- Use the `@csrf_protect` decorator for specific views if middleware is disabled:
  ```python
  from django.views.decorators.csrf import csrf_protect

  @csrf_protect
  class UpdateEmailView(View):
      def post(self, request):
          email = request.POST.get('email')
          return HttpResponse(f"Email updated to {email}")
  ```

#### 2. **Java (Spring) - Fund Transfer**
**Scenario**: A Spring-based banking application allows fund transfers via a POST request. The endpoint lacks CSRF protection, enabling attackers to forge transfer requests.

```java
package com.example.demo面

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TransferController {
    @PostMapping("/transfer")
    public String transferFunds(@RequestParam String toAccount, @RequestParam double amount) {
        // Vulnerable: No CSRF token validation
        // Simulate fund transfer logic
        return "Transferred " + amount + " to " + toAccount;
    }
}
```

**Why It’s Vulnerable**:
- The `/transfer` endpoint processes a state-changing POST request without requiring a CSRF token.
- An attacker can craft a malicious form or script to submit a POST request to `https://bank.com/transfer?toAccount=attacker&amount=1000` using the user’s active session.
- Spring’s CSRF protection is not enabled, leaving the endpoint exposed.

**How to Mitigate**:
- Enable Spring Security’s CSRF protection by including the CSRF token in forms:
  ```html
  <form method="POST" action="/transfer">
      <input type="hidden" name="_csrf" th:value="${_csrf.token}" />
      <input type="text" name="toAccount" />
      <input type="number" name="amount" />
      <button type="submit">Transfer</button>
  </form>
  ```
- Configure Spring Security to enforce CSRF checks:
  ```java
  @EnableWebSecurity
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
      }
  }
  ```
- Validate the CSRF token in the controller or use Spring’s automatic CSRF validation.

#### 3. **PHP (Laravel) - Delete User Account**
**Scenario**: A Laravel application allows admins to delete user accounts via a GET request. Using GET for state-changing actions makes it vulnerable to CSRF via simple URL manipulation.

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class UserController extends Controller
{
    public function delete($userId)
    {
        // Vulnerable: State-changing action via GET request
        DB::table('users')->where('id', $userId)->delete();
        return "User deleted";
    }
}
?>
<!-- routes/web.php -->
<?php
Route::get('/delete/{userId}', [UserController::class, 'delete']);
?>
```

**Why It’s Vulnerable**:
- The `delete` action uses a GET request, which can be triggered by embedding the URL (e.g., `https://app.com/delete/123`) in an `<img>` or `<a>` tag on a malicious site.
- No CSRF token is required or validated, allowing attackers to exploit the user’s session.
- GET requests for state-changing actions are inherently insecure, as browsers can prefetch or auto-load such URLs.

**How to Mitigate**:
- Use POST or DELETE methods for state-changing actions instead of GET.
- Enable Laravel’s CSRF protection by adding `@csrf` to forms:
  ```html
  <form method="POST" action="/delete/123">
      @csrf
      <button type="submit">Delete User</button>
  </form>
  ```
- Update the route to use POST:
  ```php
  Route::post('/delete/{userId}', [UserController::class, 'delete']);
  ```
- Ensure Laravel’s `VerifyCsrfToken` middleware is enabled in `app/Http/Kernel.php`:
  ```php
  protected $middlewareGroups = [
      'web' => [
          \App\Http\Middleware\VerifyCsrfToken::class,
      ],
  ];
  ```

---

### Finding CSRF Vulnerabilities Using DAST

Dynamic Application Security Testing (DAST) can help identify CSRF vulnerabilities by simulating malicious requests. Here’s how to do it:

1. **Identify State-Changing Endpoints**:
   - Use tools like Burp Suite or OWASP ZAP to crawl the application and identify forms, APIs, or endpoints that perform actions (e.g., POST, PUT, DELETE requests).

2. **Test Without CSRF Tokens**:
   - Submit forms or API requests without including the CSRF token or with an invalid token.
   - Check if the application processes the request, indicating a lack of CSRF protection.

3. **Simulate Malicious Requests**:
   - Create a malicious HTML page with a form that submits to the target endpoint (e.g., `<form action="https://target.com/update_email" method="POST">`).
   - Host the page on a local server and access it while logged into the target application to see if the action is executed.

4. **Test GET Requests**:
   - Identify GET requests that modify data (e.g., `GET /delete?id=123`) and test if they can be triggered via `<img>` or `<a>` tags.
   - Example: Embed `<img src="https://target.com/delete?id=123">` in a malicious page and check if the action occurs.

5. **Automate with DAST Tools**:
   - Use Burp Suite Professional or OWASP ZAP to scan for CSRF vulnerabilities by submitting forms without tokens or manipulating headers.
   - Configure tools to detect missing CSRF tokens or improper validation in responses.

6. **Analyze Responses**:
   - Check if the application accepts requests without tokens or from untrusted origins.
   - Look for success responses (e.g., “Action completed”) when tokens are missing or invalid.

**Example DAST Workflow with Burp Suite**:
- **Step 1**: Use Burp’s Spider to map all forms and state-changing endpoints.
- **Step 2**: Intercept a form submission, remove the CSRF token, and forward the request.
- **Step 3**: Check if the server processes the request (e.g., returns a success message).
- **Step 4**: Create a malicious HTML page with a forged form and test it in a logged-in browser session.
- **Step 5**: Validate findings by testing with different user sessions and origins.

**Challenges in DAST for CSRF**:
- Automated tools may miss CSRF vulnerabilities if tokens are present but not properly validated.
- Testing requires simulating a logged-in user session, which may need multiple accounts.
- Manual testing is often necessary to confirm vulnerabilities in complex workflows.

---

### Mitigation of CSRF Vulnerabilities

1. **Use CSRF Tokens**:
   - Include a unique, unpredictable CSRF token in every state-changing form or AJAX request.
   - Validate the token on the server side to ensure it matches the user’s session.

2. **Use POST/DELETE for State-Changing Actions**:
   - Avoid using GET requests for actions that modify data, as they can be triggered automatically by browsers.

3. **Validate Origin/Referer Headers**:
   - Check the `Origin` or `Referer` HTTP headers to ensure requests come from trusted domains.
   - Example (in a custom middleware):
     ```php
     if (request()->header('Origin') !== config('app.url')) {
         abort(403, 'Invalid Origin');
     }
     ```

4. **Enable Framework CSRF Protection**:
   - Use built-in CSRF protection in frameworks like Django (`CsrfViewMiddleware`), Laravel (`VerifyCsrfToken`), or Spring Security.

5. **Use SameSite Cookies**:
   - Set the `SameSite` attribute on session cookies to `Strict` or `Lax` to prevent them from being sent in cross-site requests:
     ```php
     session_set_cookie_params(['samesite' => 'Strict']);
     ```

6. **Secure Session Management**:
   - Ensure session tokens are unpredictable and tied to the user’s identity.
   - Implement timeouts for idle sessions to reduce the attack window.

7. **Security Testing**:
   - Regularly test for CSRF using DAST tools and manual penetration testing.
   - Conduct code reviews to ensure tokens are implemented correctly.

---

### Quick Notes on CSRF (5-6 Points)

- **Definition**: CSRF tricks authenticated users into performing unintended actions using their session.
- **Attack Vector**: Malicious forms, links, or scripts on external sites exploit active sessions.
- **Key Indicator**: Missing or improperly validated CSRF tokens in state-changing requests.
- **Prevention**: Use CSRF tokens, POST/DELETE methods, and SameSite cookies.
- **Impact**: Unauthorized actions, data manipulation, or financial loss.
- **Testing**: Use DAST tools like Burp Suite to simulate forged requests and check responses.

---

### Top Advanced Interview Questions on CSRF

1. **Question**: How can an attacker bypass CSRF protection if the application only checks the Referer header, and how would you secure it?

   **Answer**: Attackers can bypass Referer-based CSRF protection by:
   - Suppressing the `Referer` header using meta tags (e.g., `<meta name="referrer" content="no-referrer">`).
   - Exploiting browsers or proxies that strip or spoof the `Referer` header.
   - Using techniques like CORS misconfigurations to forge requests from trusted domains.
   To secure it:
   - Use CSRF tokens instead of relying solely on `Referer` or `Origin` headers.
   - Validate tokens against the user’s session on the server side.
   - Combine with `SameSite=Strict` cookies to prevent cross-site requests.
   - Implement strict `Origin` header validation and fallback to `Referer` only if necessary.

2. **Question**: How does the SameSite cookie attribute enhance CSRF protection, and what are its limitations?

   **Answer**: The `SameSite` attribute (`Strict` or `Lax`) prevents cookies from being sent in cross-site requests:
   - `SameSite=Strict`: Cookies are only sent for same-site requests, blocking all cross-site requests.
   - `SameSite=Lax`: Cookies are sent for top-level navigation (e.g., clicking a link) but not for embedded requests (e.g., `<img>` tags).
   **Limitations**:
   - Older browsers may not support `SameSite`, requiring fallback CSRF tokens.
   - `Lax` allows some cross-site requests (e.g., GET-based navigation), so state-changing actions should use POST.
   - Does not protect against same-site attacks (e.g., subdomain takeovers).
   Combine with CSRF tokens and POST requests for robust protection.

3. **Question**: How would you detect and mitigate CSRF vulnerabilities in a microservices architecture where multiple services handle state-changing requests?

   **Answer**: **Detection**:
   - Map all microservices and their state-changing endpoints using DAST tools like Burp Suite.
   - Test each service by submitting requests without CSRF tokens or from untrusted origins.
   - Use manual testing to simulate cross-service CSRF attacks, ensuring tokens are validated across services.
   **Mitigation**:
   - Implement centralized CSRF token generation and validation via an API gateway or shared library.
   - Use OAuth or JWT for inter-service authentication, ensuring tokens are scoped to specific actions.
   - Validate `Origin` headers at the gateway level to ensure requests come from trusted domains.
   - Use `SameSite=Strict` cookies for session management across services.
   - Standardize CSRF protection across all services using framework middleware (e.g., Spring, Laravel).

4. **Question**: How can CSRF vulnerabilities be exploited in AJAX-based applications, and what are the best practices to secure them?

   **Answer**: **Exploitation**:
   - Attackers send AJAX requests to state-changing endpoints (e.g., `POST /update_profile`) using `XMLHttpRequest` or `fetch` from a malicious site.
   - If the endpoint lacks CSRF token validation, the request uses the user’s session cookies, executing the action.
   - Example: A malicious script sends `fetch('https://target.com/update_profile', {method: 'POST', body: 'email=attacker@evil.com'})`.
   **Best Practices**:
   - Include CSRF tokens in AJAX request headers (e.g., `X-CSRF-Token`).
     ```javascript
     fetch('/update_profile', {
         method: 'POST',
         headers: { 'X-CSRF-Token': getCsrfToken() },
         body: JSON.stringify({ email: 'user@example.com' })
     });
     ```
   - Validate tokens server-side against the user’s session.
   - Use `SameSite=Strict` cookies to block cross-site AJAX requests.
   - Restrict CORS policies to trusted origins (e.g., `Access-Control-Allow-Origin: https://trusted.com`).

5. **Question**: What are the challenges of implementing CSRF protection in a single-page application (SPA) with a stateless backend?

   **Answer**: **Challenges**:
   - SPAs often use token-based authentication (e.g., JWT), which may not be tied to server-side sessions, complicating CSRF token validation.
   - Stateless backends lack session state to correlate CSRF tokens, requiring alternative mechanisms.
   - AJAX-heavy SPAs make it harder to include CSRF tokens in every request.
   - Cross-origin requests in SPAs increase the risk of misconfigured CORS policies.
   **Solutions**:
   - Store CSRF tokens in client-side storage (e.g., localStorage) and include them in request headers:
     ```javascript
     const token = localStorage.getItem('csrf_token');
     fetch('/api/update', { method: 'POST', headers: { 'X-CSRF-Token': token } });
     ```
   - Use JWT with a `nonce` claim to act as a CSRF token, validated server-side.
   - Implement strict CORS policies and validate `Origin` headers.
   - Use `SameSite=Lax` or `Strict` cookies for any session-based authentication.
   - Regularly rotate CSRF tokens to reduce the risk of token theft.

---
